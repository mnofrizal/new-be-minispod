// This is your Prisma schema file
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// EXISTING MODELS (Keep as is)
// ============================================================================
enum Role {
  ADMINISTRATOR
  USER
}

model User {
  id        String   @id @default(cuid())
  name      String
  email     String   @unique
  phone     String?  @unique
  role      Role     @default(USER)
  avatar    String?
  password  String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // EXISTING RELATIONS
  refreshTokens RefreshToken[]

  // NEW RELATIONS - Service Catalog & Credit System
  creditBalance Decimal @default(0) @db.Decimal(12, 2) // Credit balance in IDR
  totalTopUp    Decimal @default(0) @db.Decimal(12, 2) // Total lifetime top-up
  totalSpent    Decimal @default(0) @db.Decimal(12, 2) // Total lifetime spending

  subscriptions Subscription[]
  transactions  Transaction[]

  @@map("users")
}

model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("refresh_tokens")
}

// ============================================================================
// SERVICE CATALOG MODELS
// ============================================================================

// Service Categories (Development Tools, CMS, etc.)
model ServiceCategory {
  id          String   @id @default(cuid())
  name        String   @unique // "Development Tools", "CMS"
  slug        String   @unique // "dev-tools", "cms"
  description String?
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  services Service[]

  @@map("service_categories")
}

// Service Templates (N8N, Ghost, etc.)
model Service {
  id              String  @id @default(cuid())
  name            String // "N8N Automation", "Ghost Blog"
  slug            String  @unique // "n8n-automation", "ghost-blog"
  description     String?
  longDescription String?
  icon            String?
  version         String // "latest", "1.0.0"

  // Kubernetes Configuration
  dockerImage String // "n8nio/n8n:latest"
  defaultPort Int    @default(3000)

  // Resource Requirements (minimum)
  minCpuMilli  Int @default(100) // 0.1 CPU
  minMemoryMb  Int @default(128) // 128MB RAM
  minStorageGb Int @default(1) // 1GB storage

  categoryId String
  category   ServiceCategory @relation(fields: [categoryId], references: [id])

  envTemplate   Json? // Default environment variables
  tags          String[] // ["automation", "workflow"]
  documentation String?

  isActive   Boolean @default(true)
  isPublic   Boolean @default(true)
  isFeatured Boolean @default(false)
  sortOrder  Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  plans         ServicePlan[]
  subscriptions Subscription[]

  @@map("services")
}

// Service Plans with Quota System
enum PlanType {
  FREE
  BASIC
  PRO
  PREMIUM
  ENTERPRISE
}

model ServicePlan {
  id        String  @id @default(cuid())
  serviceId String
  service   Service @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  name        String // "Free", "Basic", "Pro"
  planType    PlanType
  description String?

  // Pricing
  monthlyPrice Decimal @db.Decimal(10, 2) // Monthly price in IDR
  setupFee     Decimal @default(0) @db.Decimal(10, 2)

  // Resource Allocations
  cpuMilli  Int // CPU in millicores
  memoryMb  Int // Memory in MB
  storageGb Int // Storage in GB
  bandwidth Int @default(0) // Monthly bandwidth in GB

  // SIMPLIFIED QUOTA SYSTEM - Server Resource Management
  totalQuota Int // Total available slots
  usedQuota  Int @default(0) // Currently used slots
  // availableQuota = totalQuota - usedQuota (calculated in code)

  features            Json? // Array of features
  maxInstancesPerUser Int   @default(1)
  maxDomains          Int   @default(1)

  isActive  Boolean @default(true)
  isPopular Boolean @default(false)
  sortOrder Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  subscriptions Subscription[]

  @@unique([serviceId, planType])
  @@map("service_plans")
}

// ============================================================================
// SUBSCRIPTION & BILLING MODELS
// ============================================================================

enum SubscriptionStatus {
  ACTIVE
  SUSPENDED
  CANCELLED
  EXPIRED
  PENDING_UPGRADE
  PENDING_PAYMENT
}

model Subscription {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  serviceId String
  service   Service @relation(fields: [serviceId], references: [id])

  planId String
  plan   ServicePlan @relation(fields: [planId], references: [id])

  status SubscriptionStatus @default(ACTIVE)

  // Billing Information
  startDate   DateTime  @default(now())
  endDate     DateTime // Next billing date
  lastBilled  DateTime?
  nextBilling DateTime?

  // Credit-based Billing
  monthlyPrice     Decimal  @db.Decimal(10, 2) // Cached price
  lastChargeAmount Decimal? @db.Decimal(10, 2)
  failedCharges    Int      @default(0)

  // Upgrade System
  previousPlanId String?
  upgradeDate    DateTime?
  downgradeTo    String?

  autoRenew      Boolean   @default(true)
  gracePeriodEnd DateTime? // When service will be suspended

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  instances    ServiceInstance[]
  transactions Transaction[]

  // BUSINESS RULE: One active subscription per user per service
  @@unique([userId, serviceId], name: "unique_user_service_subscription")
  @@map("subscriptions")
}

// ============================================================================
// CREDIT & TRANSACTION SYSTEM
// ============================================================================

enum TransactionType {
  TOP_UP // User top-up credit
  SUBSCRIPTION // Monthly subscription charge
  UPGRADE // Upgrade cost difference
  REFUND // Refund from cancellation
  ADMIN_ADJUSTMENT // Manual admin adjustment
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum PaymentMethod {
  MIDTRANS_BANK_TRANSFER // BCA, BNI, BRI, Mandiri
  MIDTRANS_E_WALLET // GoPay, OVO, DANA, LinkAja
  MIDTRANS_CREDIT_CARD // Visa, Mastercard
  MIDTRANS_QRIS // QRIS payment
  ADMIN_MANUAL // Manual admin adjustment
}

model Transaction {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  type   TransactionType
  status TransactionStatus @default(PENDING)
  amount Decimal           @db.Decimal(12, 2) // Amount in IDR

  // Balance Information
  balanceBefore Decimal @db.Decimal(12, 2)
  balanceAfter  Decimal @db.Decimal(12, 2)

  // Payment Information
  paymentMethod    PaymentMethod?
  paymentReference String?
  paymentProof     String?

  subscriptionId String?
  subscription   Subscription? @relation(fields: [subscriptionId], references: [id])

  description String
  metadata    Json?

  processedBy String?
  adminNotes  String?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?

  @@map("transactions")
}

// ============================================================================
// SERVICE INSTANCES & KUBERNETES
// ============================================================================

enum InstanceStatus {
  PENDING
  PROVISIONING
  RUNNING
  STOPPED
  ERROR
  TERMINATED
  MAINTENANCE
}

model ServiceInstance {
  id             String       @id @default(cuid())
  subscriptionId String
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  // NOTE: Service information is accessed via subscription.plan.service
  // This creates a cleaner architecture where instances belong only to subscriptions

  // Instance Configuration
  name      String
  subdomain String @unique // "myapp.minispod.com"

  // Kubernetes Information
  namespace      String // K8s namespace
  podName        String?
  serviceName    String?
  ingressName    String?
  deploymentName String?

  status          InstanceStatus @default(PENDING)
  healthStatus    String?
  lastHealthCheck DateTime?

  envVars      Json?
  customDomain String?
  sslEnabled   Boolean @default(false)

  // Resource Usage (cached from K8s)
  cpuUsage     Decimal? @db.Decimal(5, 2)
  memoryUsage  Decimal? @db.Decimal(8, 2)
  storageUsage Decimal? @db.Decimal(8, 2)

  publicUrl String?
  adminUrl  String?

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  lastStarted DateTime?
  lastStopped DateTime?

  @@map("service_instances")
}

// ============================================================================
// QUOTA MANAGEMENT - SIMPLIFIED (No QuotaLog needed for MVP)
// ============================================================================
// Quota tracking is handled directly in ServicePlan model
// with simple totalQuota and usedQuota fields
