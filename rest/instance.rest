### Variables
@baseUrl = http://localhost:3000/api
@jwt_token = {{admin_login.response.body.data.accessToken}}
@subscriptionId = cluser123-subscription-id
@instanceId = cluser123-instance-id
@planId = cluser123-plan-id


# @name admin_login
POST {{baseUrl}}/auth/login
Content-Type: application/json

{
  "email": "admin@minispod.com",
  "password": "password123"
}

### ==============================================
### INSTANCE MANAGEMENT ENDPOINTS
### ==============================================

### 1. Create Service Instance from Subscription
POST {{baseUrl}}/instances
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
  "subscriptionId": "{{subscriptionId}}"
}

### 2. Get User's Service Instances
GET {{baseUrl}}/instances
Authorization: Bearer {{jwt_token}}

### 3. Get User's Service Instances with Status Filter
GET {{baseUrl}}/instances?status=RUNNING
Authorization: Bearer {{jwt_token}}

### 4. Get User's Service Instances Including Terminated
GET {{baseUrl}}/instances?includeTerminated=true
Authorization: Bearer {{jwt_token}}

### 5. Get Service Instance Details
GET {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### 6. Update Service Instance (Upgrade)
PUT {{baseUrl}}/instances/{{instanceId}}/update
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
  "planId": "{{planId}}"
}

### 7. Get Instance Logs
GET {{baseUrl}}/instances/cmesh063j0005vv2d9du7epdv/logs
Authorization: Bearer {{jwt_token}}

### 8. Get Instance Logs with Parameters
GET {{baseUrl}}/instances/{{instanceId}}/logs?lines=50&follow=false
Authorization: Bearer {{jwt_token}}

### 9. Restart Service Instance
POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart
Authorization: Bearer {{jwt_token}}

### 10. Terminate Service Instance
DELETE {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### ==============================================
### INTEGRATION TEST SCENARIOS
### ==============================================

### Scenario 1: Complete Instance Lifecycle
### Step 1: Create instance from subscription
POST {{baseUrl}}/instances
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
  "subscriptionId": "{{subscriptionId}}"
}

### Step 2: Check instance status
GET {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### Step 3: Get instance logs
GET {{baseUrl}}/instances/{{instanceId}}/logs?lines=100
Authorization: Bearer {{jwt_token}}

### Step 4: Update instance (upgrade)
PUT {{baseUrl}}/instances/{{instanceId}}/update
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
  "planId": "{{planId}}"
}

### Step 5: Restart instance
POST {{baseUrl}}/instances/{{instanceId}}/restart
Authorization: Bearer {{jwt_token}}

### Step 6: Terminate instance
DELETE {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### ==============================================
### ERROR HANDLING TESTS
### ==============================================

### Test 1: Create instance without subscription ID
POST {{baseUrl}}/instances
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
}

### Test 2: Create instance with invalid subscription ID
POST {{baseUrl}}/instances
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
  "subscriptionId": "invalid-subscription-id"
}

### Test 3: Get non-existent instance
GET {{baseUrl}}/instances/non-existent-instance-id
Authorization: Bearer {{jwt_token}}

### Test 4: Update instance without plan ID
PUT {{baseUrl}}/instances/{{instanceId}}/update
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
}

### Test 5: Update instance with invalid plan ID
PUT {{baseUrl}}/instances/{{instanceId}}/update
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
  "planId": "invalid-plan-id"
}

### Test 6: Access instance without authentication
GET {{baseUrl}}/instances/{{instanceId}}

### Test 7: Get instances with invalid status filter
GET {{baseUrl}}/instances?status=INVALID_STATUS
Authorization: Bearer {{jwt_token}}

### Test 8: Get logs with invalid parameters
GET {{baseUrl}}/instances/{{instanceId}}/logs?lines=2000&follow=invalid
Authorization: Bearer {{jwt_token}}

### ==============================================
### PERFORMANCE TESTS
### ==============================================

### Test 1: Get all instances (performance test)
GET {{baseUrl}}/instances
Authorization: Bearer {{jwt_token}}

### Test 2: Get instance details multiple times
GET {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### Test 3: Get logs with different line counts
GET {{baseUrl}}/instances/{{instanceId}}/logs?lines=10
Authorization: Bearer {{jwt_token}}

###
GET {{baseUrl}}/instances/{{instanceId}}/logs?lines=100
Authorization: Bearer {{jwt_token}}

###
GET {{baseUrl}}/instances/{{instanceId}}/logs?lines=500
Authorization: Bearer {{jwt_token}}

### ==============================================
### KUBERNETES INTEGRATION TESTS
### ==============================================

### Test 1: Create instance and check Kubernetes resources
POST {{baseUrl}}/instances
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
  "subscriptionId": "{{subscriptionId}}"
}

### Test 2: Monitor provisioning status
GET {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### Test 3: Check instance after provisioning complete
GET {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### Test 4: Update instance resources
PUT {{baseUrl}}/instances/{{instanceId}}/update
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
  "planId": "{{planId}}"
}

### Test 5: Verify resource update
GET {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### Test 6: Terminate and cleanup
DELETE {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### ==============================================
### ADMIN MONITORING (Use admin token)
### ==============================================

### Check Kubernetes pods (admin only)
GET {{baseUrl}}/admin/k8s/pods
Authorization: Bearer {{jwt_token}}

### Check Kubernetes deployments (admin only)
GET {{baseUrl}}/admin/k8s/deployments
Authorization: Bearer {{jwt_token}}

### Check Kubernetes services (admin only)
GET {{baseUrl}}/admin/k8s/services
Authorization: Bearer {{jwt_token}}

### Check Kubernetes ingresses (admin only)
GET {{baseUrl}}/admin/k8s/ingresses
Authorization: Bearer {{jwt_token}}

### ==============================================
### POD NAME SYNCHRONIZATION TESTS
### ==============================================

### Test 1: Verify pod name before subscription upgrade
GET {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### Test 2: Perform subscription upgrade (triggers pod restart)
# Note: This should be done via subscription upgrade endpoint
# PUT {{baseUrl}}/subscriptions/{{subscriptionId}}/upgrade

### Test 3: Verify pod name after subscription upgrade
GET {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### Test 4: Check Kubernetes pods to verify new pod exists
GET {{baseUrl}}/admin/k8s/pods
Authorization: Bearer {{jwt_token}}

### Test 5: Check deployment status after upgrade
GET {{baseUrl}}/admin/k8s/deployments
Authorization: Bearer {{jwt_token}}

### Test 6: Manual pod name refresh (maintenance function)
# Note: This endpoint would need to be added to instance controller
# POST {{baseUrl}}/instances/{{instanceId}}/refresh-pod-name

### ==============================================
### POD NAME VERIFICATION WORKFLOW
### ==============================================

### Step 1: Create instance and note initial pod name
POST {{baseUrl}}/instances
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

{
  "subscriptionId": "{{subscriptionId}}"
}

### Step 2: Wait for provisioning and get initial pod name
GET {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### Step 3: Upgrade subscription (this triggers pod restart)
# Use subscription upgrade endpoint which calls updateServiceInstance
# PUT {{baseUrl}}/subscriptions/{{subscriptionId}}/upgrade

### Step 4: Verify pod name is updated after upgrade
GET {{baseUrl}}/instances/{{instanceId}}
Authorization: Bearer {{jwt_token}}

### Step 5: Cross-verify with Kubernetes API
GET {{baseUrl}}/admin/k8s/pods
Authorization: Bearer {{jwt_token}}

### ==============================================
### NOTES
### ==============================================

# Instance Status Flow:
# PENDING -> PROVISIONING -> RUNNING -> (TERMINATED)
#                         -> ERROR (if provisioning fails)

# Available Instance Statuses:
# - PENDING: Instance created, provisioning not started
# - PROVISIONING: Kubernetes resources being created
# - RUNNING: Instance is running and healthy
# - STOPPED: Instance is stopped but not terminated
# - ERROR: Provisioning or runtime error occurred
# - TERMINATED: Instance has been terminated and cleaned up
# - MAINTENANCE: Instance is under maintenance

# Instance Operations:
# - CREATE: Provision new instance from subscription
# - READ: Get instance details and status
# - UPDATE: Upgrade instance resources (from subscription upgrade)
# - DELETE: Terminate instance and cleanup resources
# - RESTART: Restart running instance
# - LOGS: Get instance logs and monitoring data

# Integration Points:
# - Subscription Service: Instance creation from active subscriptions
# - Kubernetes Cluster: Resource provisioning and management
# - Quota Service: Resource allocation and limits
# - Monitoring: Health checks and metrics collection

### ==============================================
### RESTART INSTANCE FUNCTIONALITY TESTS
### ==============================================

### Test 1: Restart Running Instance (Success Case)
POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### Test 2: Restart Non-existent Instance (should fail)
POST {{baseUrl}}/instances/non-existent-instance-id/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### Test 3: Restart Instance Without Authentication (should fail)
POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart
Content-Type: application/json

### Test 4: Restart Instance with Invalid JWT (should fail)
POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart
Authorization: Bearer invalid_jwt_token
Content-Type: application/json

### Test 5: Restart Instance Belonging to Another User (should fail)
# Note: Use different user's instance ID
POST {{baseUrl}}/instances/other-user-instance-id/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### Test 6: Restart Instance with ERROR Status (should fail)
# Note: Use instance ID that has ERROR status
POST {{baseUrl}}/instances/error-status-instance-id/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### Test 7: Restart Instance with TERMINATED Status (should fail)
# Note: Use instance ID that has TERMINATED status
POST {{baseUrl}}/instances/terminated-instance-id/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### ==============================================
### RESTART WORKFLOW TESTS
### ==============================================

### Workflow Test 1: Check Instance Status Before Restart
GET {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44
Authorization: Bearer {{jwt_token}}

### Workflow Test 2: Perform Restart
POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### Workflow Test 3: Check Instance Status After Restart (should show new pod name)
GET {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44
Authorization: Bearer {{jwt_token}}

### Workflow Test 4: Verify Kubernetes Pods (should show new pod)
GET {{baseUrl}}/admin/k8s/pods
Authorization: Bearer {{jwt_token}}

### Workflow Test 5: Check Instance Logs After Restart
GET {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/logs?lines=50
Authorization: Bearer {{jwt_token}}

### ==============================================
### RESTART VS RETRY PROVISIONING COMPARISON
### ==============================================

### Scenario 1: Restart Running Instance (Rolling Restart)
# Use case: Service is running but has issues (memory leak, hung processes)
# Expected: Pod is restarted with minimal downtime, same configuration
POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### Scenario 2: Retry Provisioning for Failed Instance (Full Redeploy)
# Use case: Service deployment failed completely (ERROR status)
# Expected: Complete cleanup and redeploy from scratch
POST {{baseUrl}}/subscriptions/cmeslquvy0005vv4auasdgjzh/retry-provisioning
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### ==============================================
### RESTART RESPONSE STRUCTURE VALIDATION
### ==============================================

### Test Expected Restart Response Structure
POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

# Expected Response Structure:
# {
#   "success": true,
#   "statusCode": 200,
#   "data": {
#     "instance": {
#       "id": "cmeslquw90007vv4azb9pes44",
#       "name": "n8n-automation-user123",
#       "status": "RUNNING",
#       "service": { "name": "N8N Automation", "slug": "n8n-automation" },
#       "plan": { "name": "Basic", "planType": "BASIC" }
#     },
#     "restart": {
#       "oldPodName": "n8n-automation-user123-abc123",
#       "newPodName": "n8n-automation-user123-def456",
#       "restartTime": "2025-08-27T14:35:00.000Z",
#       "method": "Rolling Restart"
#     },
#     "message": "Service instance restarted successfully",
#     "estimatedDowntime": "< 30 seconds",
#     "nextSteps": [
#       "New pod is being created with fresh state",
#       "Old pod will be terminated gracefully",
#       "Service should be available shortly",
#       "Check instance status for updates"
#     ]
#   },
#   "message": "Service instance restart initiated successfully",
#   "timestamp": "2025-08-27T14:35:00.123Z"
# }

### ==============================================
### RESTART PERFORMANCE TESTS
### ==============================================

### Performance Test 1: Measure Restart Time
# Step 1: Record start time and restart
POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### Performance Test 2: Monitor Restart Progress
# Step 2: Check status immediately after restart
GET {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44
Authorization: Bearer {{jwt_token}}

### Performance Test 3: Verify Service Availability
# Step 3: Check if service is accessible (wait 30 seconds then test)
GET {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44
Authorization: Bearer {{jwt_token}}

### ==============================================
### RESTART EDGE CASES
### ==============================================

### Edge Case 1: Restart During Provisioning (should fail)
# Note: Use instance that is currently in PROVISIONING status
POST {{baseUrl}}/instances/provisioning-instance-id/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### Edge Case 2: Multiple Restart Requests (should handle gracefully)
# First restart request
POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### Immediate second restart request (should fail or queue)
POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart
Authorization: Bearer {{jwt_token}}
Content-Type: application/json

### Edge Case 3: Restart When Kubernetes Unavailable (should fail gracefully)
# Note: This would require temporarily disabling K8s connection
# POST {{baseUrl}}/instances/cmeslquw90007vv4azb9pes44/restart

### ==============================================
### RESTART FUNCTIONALITY NOTES
### ==============================================

# Restart vs Retry Provisioning:
#
# RESTART INSTANCE:
# - For RUNNING instances that have issues
# - Kubernetes rolling restart (minimal downtime)
# - Same configuration, fresh pod
# - Downtime: < 30 seconds
# - Use case: Memory leaks, hung processes, performance issues
#
# RETRY PROVISIONING:
# - For ERROR/TERMINATED instances
# - Complete cleanup and redeploy
# - New configuration from subscription
# - Downtime: 2-5 minutes
# - Use case: Deployment failures, configuration errors
#
# Restart Business Rules:
# - Only works for RUNNING instances
# - User can only restart their own instances
# - Kubernetes cluster must be available
# - Rolling restart preserves service availability
# - New pod gets fresh state but same configuration
# - Pod name changes after restart
# - Health status updated to "Healthy - Restarted"
#
# Frontend Implementation Notes:
# - Show restart button only for RUNNING instances
# - Disable restart button during restart process
# - Poll instance status after restart to show progress
# - Display estimated downtime and next steps to user
# - Handle all error scenarios gracefully
# - Show pod name changes for debugging

### ============================================================================
### STOP INSTANCE FUNCTIONALITY (NEW)
### ============================================================================

### Test 1: Stop Running Instance (Success Case)
PUT {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy/stop
Authorization: Bearer {{authToken}}
Content-Type: application/json

### Test 2: Stop Non-existent Instance (should fail)
PUT {{baseUrl}}/instances/clnonexistentinstance/stop
Authorization: Bearer {{authToken}}
Content-Type: application/json

### Test 3: Stop Instance Without Authentication (should fail)
PUT {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy/stop
Content-Type: application/json

### Test 4: Stop Instance with Invalid JWT (should fail)
PUT {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy/stop
Authorization: Bearer invalid_jwt_token
Content-Type: application/json

### Test 5: Stop Already Stopped Instance (should fail)
# Note: Use instance ID that is already stopped
PUT {{baseUrl}}/instances/already-stopped-instance/stop
Authorization: Bearer {{authToken}}
Content-Type: application/json

### ============================================================================
### START INSTANCE FUNCTIONALITY (NEW)
### ============================================================================

### Test 6: Start Stopped Instance (Success Case)
PUT {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy/start
Authorization: Bearer {{authToken}}
Content-Type: application/json

### Test 7: Start Non-existent Instance (should fail)
PUT {{baseUrl}}/instances/clnonexistentinstance/start
Authorization: Bearer {{authToken}}
Content-Type: application/json

### Test 8: Start Instance Without Authentication (should fail)
PUT {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy/start
Content-Type: application/json

### Test 9: Start Instance with Invalid JWT (should fail)
PUT {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy/start
Authorization: Bearer invalid_jwt_token
Content-Type: application/json

### Test 10: Start Already Running Instance (should fail)
# Note: Use instance ID that is already running
PUT {{baseUrl}}/instances/already-running-instance/start
Authorization: Bearer {{authToken}}
Content-Type: application/json

### ============================================================================
### STOP/START WORKFLOW TESTS
### ============================================================================

### Workflow Test 1: Check Instance Status Before Stop
GET {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy
Authorization: Bearer {{authToken}}

### Workflow Test 2: Stop Running Instance
PUT {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy/stop
Authorization: Bearer {{authToken}}
Content-Type: application/json

### Workflow Test 3: Check Instance Status After Stop (should show STOPPED)
GET {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy
Authorization: Bearer {{authToken}}

### Workflow Test 4: Start Stopped Instance
PUT {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy/start
Authorization: Bearer {{authToken}}
Content-Type: application/json

### Workflow Test 5: Check Instance Status After Start (should show RUNNING)
GET {{baseUrl}}/instances/cmeu4cgod0009vvborivibrmy
Authorization: Bearer {{authToken}}

### ============================================================================
### STOP/START FUNCTIONALITY NOTES
### ============================================================================

# Stop/Start vs Other Operations:
#
# STOP INSTANCE:
# - Temporary operation: scales deployment to 0 replicas
# - Preserves all configuration and persistent data
# - Status changes: RUNNING → STOPPING → STOPPED
# - Resources freed up while stopped
# - Can be reversed with START operation
#
# START INSTANCE:
# - Resume operation: scales deployment to 1 replica
# - Restores service with preserved configuration
# - Status changes: STOPPED → STARTING → RUNNING
# - New pod created with same configuration
# - All data and settings restored
#
# RESTART INSTANCE:
# - Rolling restart: replaces running pod with new one
# - Minimal downtime, service stays available
# - Status changes: RUNNING → RESTARTING → RUNNING
# - Pod name changes, configuration preserved
#
# TERMINATE INSTANCE:
# - Permanent deletion: removes all Kubernetes resources
# - Status changes to TERMINATED
# - Data may be lost depending on storage
# - Cannot be reversed
#
# Stop/Start Business Rules:
# - STOP only works for RUNNING instances
# - START only works for STOPPED instances
# - User can only control their own instances
# - Kubernetes cluster must be available
# - Data and configuration are preserved during stop/start cycle
# - Pod names may change after start (new pod created)
#
# Frontend Implementation Notes:
# - Show STOP button only for running instances
# - Show START button only for stopped instances
# - Disable buttons during STOPPING/STARTING status
# - Poll instance status to show progress
# - Display clear status indicators (STOPPED vs RUNNING)
# - Handle all error scenarios with clear messages
# - Show estimated time for operations